### A Pluto.jl notebook ###
# v0.19.23

using Markdown
using InteractiveUtils

# ╔═╡ 7f9aabc0-105f-4ef6-b0c3-9f9539202f22
md"""
该教程粗略的摘录了 Julia 的基本语法，不熟悉 Julia 的同学可以先粗略地通读该教程，以大致熟悉基本操作。

如果想要了解详细内容可以查阅[官方文档](https://docs.julialang.org/en/v1/)，Julia 中文社区提供了中文版本的[文档](https://docs.juliacn.com/latest/)。 [B 站](https://www.bilibili.com/video/BV1Cb411W7Sr?p=1)有一个简单的视频教程。 这个教程的有部分代码来自该视频作者。 

如果想比较全面的学一下Julia, 可以看看Github上面的这种本[Julia编程基础](https://github.com/hyper0x/JuliaBasics/tree/master/book)
"""

# ╔═╡ a882c1f1-bbe8-4ae5-9639-269d8b8e3a05
md"""
**程序 = 数据结构+算法**， 要学会编程， 你需要知道一些基本的数据结构（类型）以及如果去操作这些数据（算法）。 数据结构可以理解为数据的组织方式。

数据保存在内存中， 为了操作特定的数据， 我们通常需要给数据取一个名字--变量名。
"""

# ╔═╡ c763528b-869d-4e25-9fef-fe30556e8ec9
md"""
# 变量
在Julia中，变量是与值关联(或绑定)的名称。当您想要存储一个值时，它很有用(例如，你经过一些数学运算后得到的)以备以后使用。 通常， 我们会用**赋值操作符（=）**实现将一个值和对应的变量名关联起来 （也就是赋值的时候，实现变量的定义）。如`x=3`， 表示把数字3跟变量x绑定起来。 赋值操作符在很多语言中都是类似的。


例如:
```julia
	# 把数值10分配给变量x， 或者说， 变量x绑定数值10
	julia> x = 10
	10
	# 用变量x绑定的数字做运算
	julia> x + 1
	11
	# 重新绑定x的值为一个表达式运算的结果
	julia> x = 1 + 1
	2
	# 也可以把变量x绑定到其他的数据类型上去（比如字符串）
	julia> x = "Hello World!"
	"Hello World!"
```
"""

# ╔═╡ da5df308-956e-4310-80e6-2286d14063e4
md"""
你可以把变量看成是**盒子**的名字。 这个盒子（内存中的某个区域）里面可以装各种类型的数据。比如， x = 10， 就可以看成是名叫x的盒子， 里面装的是数字10。 很多语言要求变量名只能是字母数字下划线构成， 在julia中，你可以使用几乎所有可能的符号做变量名。
"""

# ╔═╡ 3727eb83-7421-4d32-b3db-cafd2a5b4816
中国 = 100

# ╔═╡ 9c429008-6edd-43fa-8625-c3fbea8f2c81
中国

# ╔═╡ 5d06ed7e-d4ad-4d1b-90ef-3acae715e6d5
美国=80

# ╔═╡ a240c6aa-86f8-4f64-ad4a-dd20b632eb04
中国 - 美国

# ╔═╡ 629fb06d-cb0a-4ffa-8d1c-4a55bba71cce
π = "你好"

# ╔═╡ 46b76b9d-7edb-4163-a892-85d3d1dd6863
⬠ = "五边形"

# ╔═╡ 982351d4-7065-4836-97e3-cd138065076c
π * ⬠

# ╔═╡ 90fd182e-8580-4187-97d8-dcd44940e86a
md"""
# 基础数据类型
这里总结一些基础的数据类型， 主要有数值类型， 字符和字符串类型， 字典与集合， 数组等几种常见的类型。Julia的优势之一就是它强大的类型系统。 在Julia中，任何数据都是有类型的， 就像C语言， 从而可以使代码运算速度加快。 但与此同时， Julia也可以不指定数据类型， 这时候它会给数据一个默认的数据类型， 这让Julia写起来， 又有点像R和Python。 虽然我们可以不指定数据类型， 但知道一些基本的常识，有利于我们写出高性能的代码和读懂别人写的代码。因此， 下面过一下基本的一些数据类型。 参考[Julia编程基础第五章](https://github.com/hyper0x/JuliaBasics/blob/master/book/ch05.md)
"""

# ╔═╡ ebdd01c8-a5b9-4f29-a924-ac031967be0c
md"""
## 数值类型
数字是我们从小的开始学习的概念， 从最开始的整数到，有理数， 实数， 复数，我们接触了各种数值的概念。 在程序语言中， 数值是通常最简单、最基础的数据类型。有些语言不关注数据的具体类型， 都统一视为“数字”。 但强于科学计算的Julia语言， 有丰富的数值类型， 罗列部分如下：

		- 布尔类型：Bool
		- 有符号整数类型： BigInt、Int8、Int16、Int32、Int64和Int128
		- 无符号整数类型： UInt8、UInt16、UInt32、UInt64和UInt128
		- 浮点数类型： BigFloat、Float16、Float32和Float64
将数值细分为不同的类型是有意义的， 不仅能减少数据的存储空间， 还可以提交数据的计算效率。 当然， 如果你觉得处理这么多数据类型很麻烦， 你也可以不管数据类型。 Julia会自动选择默认的数据类型。 比如， 通常整数会当成Int64的类型（在64位的机器里）， 而带了小数点的有理数会当成Float64类型。

"""

# ╔═╡ 21bc77b9-eeaf-4d2a-ace6-d6aec98e9a4b
md"""
#### **获取对象的类型typeof**
下面的代码显示整数默认是Int64类型， 实际上， 因为我的电脑是64位， 所以显示是Int64， 如果是32位的机器上，下面的结果会是Int32.
"""

# ╔═╡ 109ba8e7-aeef-49b3-84cb-2dc1082c7f07
typeof(10), typeof(10.5)

# ╔═╡ aaa0b712-e6cd-492c-9ea0-ab2c07549754
md"""
#### 正负无穷大与不存在（Inf*, NaN*）
Inf*表示无穷大（*表示宽度）， NaN*表示不是数（Not a Number）， 参考下面的例子。
"""

# ╔═╡ d673f90f-f0d1-400f-958a-623c17d00ba5
typemax(Int64), typemax(Float64), 1/0, 0 * Inf

# ╔═╡ f0b321cd-0fa1-47c9-983a-35a5d2c1ca80
md"""
## 运算符
这里主要是总结一下Julia中的常见操作符，也称运算符（Operator）。 Julia中的运操作符是用于对变量和值执行操作的数学符号， 这些符号通常用来进行算术和逻辑计算。 操作符对其执行操作的变量称为操作数(Operands)。 比如，在表达式
`a + b` 中， a和b就是操作数，而 `+` 就是操作符。 作为入门和基础的应用， 需要我们掌握以下四种运算符： 

- 算术运算符  
- 逻辑运算符  
- 赋值操作符  
- 矢量化的点操作符  
- 比较运算符  


可参考这篇[文章](https://www.geeksforgeeks.org/operators-in-julia/)获取更多的细节描述。
"""

# ╔═╡ aea5a22c-9976-4983-b932-0cf56766aff6
md"""
### 算术运算符
算术运算符是一门语言中常见的， 主要包括 + - * /等。

|运算符| 含义 | 用法|
|-----|------|-----|
| + | 求和  | a + b |
| - | 求差  | a - b |
| * | 乘法  | a * b |
| / | 除法  | a / b |
| \ | 除法  | a \ b (等价于 b / a) |
| $\div$ | 整除 | a $\div$ b|
| % | 求余数 | a % b|
| ^ | 乘方  | a ^ b|

注意， + - 也可以用作一元运算符， 在变量前添加 + ， 不会改变变量值； 添加 - ， 会将变量变相反数。 上面的$\div$在编辑器中可以通过 \div+[TAB] 键输入。 这也是Julia特殊的地方， 它是完全支持Unicode字符的， 所以我们可以使用类似于数学书写的方式去写各种变量。 以后看到类似的数学符号， 他们都是通过相应的latex符号+ TAB键打印出来的。 你也可以通过复制一个符号， 然后用 `? 符号`的方式在REPL中获得其书写方法帮助。
下面是一些例子：
"""

# ╔═╡ 4db40a79-2b6a-4ca9-8e3f-b285140ae5f6
7 ÷ 3

# ╔═╡ eafe3147-624f-47e7-a7ed-0cc6e7f509a6
@doc ÷

# ╔═╡ 2f43fbeb-9f07-40b8-bdcc-23eb66c81b95
2^3

# ╔═╡ 14e10f91-b51d-41c3-8bef-944237d7e58c
# 定义变量， 你也可以改变这里的定义, 一次给多个变量赋值， 跟Python类似
a, b = 9, 4

# ╔═╡ 1c98d7ec-9f1a-499a-9060-94b72a8df03e
(a + b, a - b, a * b, a / b, a \ b, a \ b == b / a, a ÷ b, a % b, +a, -b)

# ╔═╡ 312f9a1c-e87b-4fbd-882c-788328e343bd
md"""
### 比较运算
比较运算主要用于对变量的大小比较，主要有大于、小于、等于，以及衍生的大于等于、小于等于、不等于等6种情况， 比较的结果通常是逻辑值 true 或 false， 常用于 if 语句等逻辑判断场景。 下面是具体用法：

|运算符| 含义 | 用法|
|-----|------|-----|
|>	| 大于: 左操作数大于右操作数时为 true	| x > y |
|<	| 小于: 左操作数小于右操作数时为 true	| x < y |
|==	| 等于： 左操作数等于右操作数时为 true    | x == y |
|!=, ≠	| 不等于： 左操作数不等于右操作数时为 true 	| x != y or x ≠ y |
|>=, ≥	| 大于或等于: 左操作数大于或等于右操作数时为 true	| x >= y or x ≥ y |
|<=, ≤	| 小于或等于: 左操作数小于或等于右操作数时为 true	| x <= y or x ≤ y |

注意， 上面几个特殊符号对应的latex代码≠ （\ne）, ≥ (\geq), ≤ (\leq) 。 
下面是几个例子：

"""

# ╔═╡ 0471bf91-5788-4ac4-8b7e-c0a262952cbf
4 ≠ 4

# ╔═╡ eacc9099-addc-4eb2-b8fd-6bea98d36408
a > b, a < b, a == b, a != b, a >= b, a <= b

# ╔═╡ cfa6971e-05b5-4aaa-b661-fa6562fecb99
md"""
### 逻辑运算符
逻辑运算符主要用于构造复合条件， 多用于程序流程控制。 主要是三种： 与（and）, 或（or）, 非（not）。 具体用法如下：

|运算符| 含义 | 用法|
|---|---|---|
| &&	| 与: 当且仅当两个操作数都是 true 时， 结果为true	| x && y|
|  \|\|	|或： 当至少有一个操作数为true时， 结果为true |	x \|\| y | 
| !	| 非： 将true变为false， false变为true | !x |

下面是几个例子， 其中`isodd`, `iseven`分别用于判断一个数是奇数和偶数。
"""

# ╔═╡ b629150d-7192-44a6-ad4e-9c0b89c3dc3f
a, b

# ╔═╡ 0b833df1-0385-4140-be7a-dba3c78de5e8
isodd(a), iseven(b), isodd(a) && isodd(b), isodd(a) || isodd(b), !isodd(a)

# ╔═╡ 0122632d-bfa9-4aa7-a0b8-af4d993910dc
md"""
### 常用数学函数
Julia 预定义了非常丰富的数学函数。一些常用的函数如下：

- 数值类型转换： 主要有T(x)和convert(T, x)。其中，T代表目的类型，x代表源值。
- 数值特殊性判断： 有isequal、isfinite、isinf和isnan。
- 舍入： 有四舍五入的round、向正无穷舍入的ceil、向负无穷舍入的floor，以及总是向0舍入的trunc。
- 绝对值获取： 用于获取绝对值的函数是abs(x)。一个相关的函数是，用于求平方的abs2(x)。
- 求根： 函数sqrt(x)用于求取x的平方根，而函数cbrt(x)则用于求取x的立方根。
- 求指数： 函数exp(x)会求取x的自然指数。另外还有expm1(x)，为接近0的x计算exp(x)-1。
- 求对数： log(x)会求取x的自然对数，log(b, x)会求以b为底的x的对数，而log2(x)和log10(x)则会分别以2和10为底求对数。另外还有log1p(x)，为接近0的x计算log(1+x)。

除了以上函数之外，Julia 的Base包中还定义了很多三角函数和双曲函数，比如sin、cos、atanh、acoth等等。另外，在SpecialFunctions.jl包里还有许多特殊的数学函数。不过这个包就需要我们手动下载了。
"""

# ╔═╡ 20f2d4b4-d78b-4e24-9474-f5b19333c495
ceil(5.6), floor(5.6)

# ╔═╡ 5bd68245-bf74-4f08-9a93-7c892372ea65
convert(Int64,10.0)

# ╔═╡ 39c55b9c-cb0b-4ed0-8216-02ab52c01f12
ceil(4.5)

# ╔═╡ 86522c2d-1258-47a5-a499-c12b57f100a0
floor(4.5)

# ╔═╡ 70f11a60-32bd-4568-ad03-3ad26020953f
md"""
### 矢量化的点操作符
点操作符是Julia中实现向量化运算的关键操作符。在R、Python等语言中， 许多运算默认都是向量化的。 但在Julia中， 情况有所不同。 在Julia中， 只要在一个运算的前面加上一个点， 这个运算就变成了向量化的了。 即这个运算会作用到运算对象的每一个元素上。 
"""

# ╔═╡ 1f90bc20-cadf-4645-9a83-499189778029
v1 = [1,2,3]; v2 = [4,5,6];

# ╔═╡ 289fcca8-8449-4c44-99c1-955df51e878b
v1 .* v2

# ╔═╡ 7b2490fd-cac1-4da7-b8f1-4903cb472533
v1.^2

# ╔═╡ 0c64dab6-5952-497c-94bf-29a215d92789
v1 .* v2

# ╔═╡ 9fdacf84-ceef-43fb-82b1-a97fb65a6ac7
typemax(Float16)

# ╔═╡ 700de0bd-265f-40f2-b988-9031720179e6
typemin(Float16)

# ╔═╡ 8fc11111-51df-412d-b310-fa68349eee96
1/0

# ╔═╡ 9427f8d1-2adb-4eea-b477-a214f690cc1a
0 * Inf

# ╔═╡ f97ecf19-3643-4b2a-9089-876de65fa2f9
md"""
## 字符与字符串
Julia支持Unicode编码， 单个的字符用**单引号**包裹。 字符串用**双引号**包裹，  也可以用三联双引号， 通常用于文档中。 字符的类型是Char， 字符串的类型是String。
"""

# ╔═╡ c62fdcbb-43d7-4743-a066-b122bf3a66cf
typeof('a')

# ╔═╡ 6189bd60-134e-45bc-b981-da05a7b774c3
'中'

# ╔═╡ 604a4580-eeb8-4155-9832-e6bdeec8c245
length("我爱Julia！")

# ╔═╡ 96271c13-fca0-46a4-9790-30801fbaa49d
md"""
#### 字符串的常用操作
- `sizeof` 获取字符串（任何对象都可以）占用的字节数。
- `length` 获取字符串的字符数量。
- `*` 字符串拼接， 也可以使用`string`函数。
- [i] 字符串索引(获取第i个字符）， 不过请注意Unicode字符串索引可能引发的问题。
- [i:j] 字符串截取（获取索引号从i到j的所有字符）。
- `$(var)` 用变量var的值插入字符串中。
- **搜索**。 `findfirst`, `findlast`, 请使用`@doc 函数名` 的方式获取其使用方法。
- occursin, contains 判断一个字符串是否包含某个子串（或模式）
- startswith， endswith 判断字符串是否以某个子串开头或结尾
- first, last 获取字符串前面或结尾的n个字符。
"""

# ╔═╡ 0ffbbd92-7a32-40c6-950f-ce67bf6a2953
"good" * "morning"

# ╔═╡ 361f6ff8-aea2-46d8-b111-81eddc103a30
id = "352719200008101112"

# ╔═╡ 374061f0-7020-4f8d-ac2c-73e60be9cb2b
parse(Int64,id[11:12])

# ╔═╡ 43161720-d202-4258-81d0-bfd4cbf7938f
str = "我爱julia！"

# ╔═╡ 2786dee7-73a3-4ec2-9eba-485d704debe1
str[1:2]

# ╔═╡ efadc49a-d796-4dee-b0ae-be15fe83e3e0
sizeof("我")

# ╔═╡ 520a56a3-faad-4210-9002-1a72ffe0e6f3
str[1:4]

# ╔═╡ 244bd7e2-09b8-4dc6-b916-73a4598150f1
sizeof("我爱")

# ╔═╡ c4c618e3-c485-4ab0-a526-9f93437e8e65
length(str)

# ╔═╡ a51a510a-2d17-4770-b982-7ee168c6e98b
sizeof(str)

# ╔═╡ 7f4c146a-e767-4989-b74a-339aa8e7f7e2
str[1:4]

# ╔═╡ 3b471035-860f-4a32-a149-5ce72b82ee65
sizeof(str)

# ╔═╡ 381ef733-af05-4da3-9848-b2efab9eed35
length(str)

# ╔═╡ 103f93df-470b-47e2-93d9-9210ae9895e5
first(str, 2)

# ╔═╡ 8e97b385-5e8a-4cc0-9257-09b1939ba6ad
contains("JuliaLang is pretty cool!", "Julia")

# ╔═╡ 42184826-69e6-4fa2-811d-36fe7fb219ee
md"""
字符串在数据分析中一种常用应用是： 我们读取的数据可能是字符串格式， 需要将其转换为数字。常使用的函数是`parse(type, str)`， 这个函数通常用于类型之间的转换。
"""

# ╔═╡ 9e2a0893-8912-4549-a050-29af947c88e1
parse(Float64, "33222.45")

# ╔═╡ Cell order:
# ╟─7f9aabc0-105f-4ef6-b0c3-9f9539202f22
# ╟─a882c1f1-bbe8-4ae5-9639-269d8b8e3a05
# ╠═c763528b-869d-4e25-9fef-fe30556e8ec9
# ╠═da5df308-956e-4310-80e6-2286d14063e4
# ╠═3727eb83-7421-4d32-b3db-cafd2a5b4816
# ╠═9c429008-6edd-43fa-8625-c3fbea8f2c81
# ╠═5d06ed7e-d4ad-4d1b-90ef-3acae715e6d5
# ╠═a240c6aa-86f8-4f64-ad4a-dd20b632eb04
# ╠═629fb06d-cb0a-4ffa-8d1c-4a55bba71cce
# ╠═46b76b9d-7edb-4163-a892-85d3d1dd6863
# ╠═982351d4-7065-4836-97e3-cd138065076c
# ╠═90fd182e-8580-4187-97d8-dcd44940e86a
# ╠═ebdd01c8-a5b9-4f29-a924-ac031967be0c
# ╠═21bc77b9-eeaf-4d2a-ace6-d6aec98e9a4b
# ╠═109ba8e7-aeef-49b3-84cb-2dc1082c7f07
# ╠═aaa0b712-e6cd-492c-9ea0-ab2c07549754
# ╠═d673f90f-f0d1-400f-958a-623c17d00ba5
# ╠═f0b321cd-0fa1-47c9-983a-35a5d2c1ca80
# ╠═aea5a22c-9976-4983-b932-0cf56766aff6
# ╠═4db40a79-2b6a-4ca9-8e3f-b285140ae5f6
# ╠═eafe3147-624f-47e7-a7ed-0cc6e7f509a6
# ╠═2f43fbeb-9f07-40b8-bdcc-23eb66c81b95
# ╠═14e10f91-b51d-41c3-8bef-944237d7e58c
# ╠═1c98d7ec-9f1a-499a-9060-94b72a8df03e
# ╠═312f9a1c-e87b-4fbd-882c-788328e343bd
# ╠═0471bf91-5788-4ac4-8b7e-c0a262952cbf
# ╠═eacc9099-addc-4eb2-b8fd-6bea98d36408
# ╠═cfa6971e-05b5-4aaa-b661-fa6562fecb99
# ╠═b629150d-7192-44a6-ad4e-9c0b89c3dc3f
# ╠═0b833df1-0385-4140-be7a-dba3c78de5e8
# ╠═0122632d-bfa9-4aa7-a0b8-af4d993910dc
# ╠═20f2d4b4-d78b-4e24-9474-f5b19333c495
# ╠═5bd68245-bf74-4f08-9a93-7c892372ea65
# ╠═39c55b9c-cb0b-4ed0-8216-02ab52c01f12
# ╠═86522c2d-1258-47a5-a499-c12b57f100a0
# ╠═70f11a60-32bd-4568-ad03-3ad26020953f
# ╠═1f90bc20-cadf-4645-9a83-499189778029
# ╠═289fcca8-8449-4c44-99c1-955df51e878b
# ╠═7b2490fd-cac1-4da7-b8f1-4903cb472533
# ╠═0c64dab6-5952-497c-94bf-29a215d92789
# ╠═9fdacf84-ceef-43fb-82b1-a97fb65a6ac7
# ╠═700de0bd-265f-40f2-b988-9031720179e6
# ╠═8fc11111-51df-412d-b310-fa68349eee96
# ╠═9427f8d1-2adb-4eea-b477-a214f690cc1a
# ╠═f97ecf19-3643-4b2a-9089-876de65fa2f9
# ╠═c62fdcbb-43d7-4743-a066-b122bf3a66cf
# ╠═6189bd60-134e-45bc-b981-da05a7b774c3
# ╠═604a4580-eeb8-4155-9832-e6bdeec8c245
# ╠═96271c13-fca0-46a4-9790-30801fbaa49d
# ╠═0ffbbd92-7a32-40c6-950f-ce67bf6a2953
# ╠═361f6ff8-aea2-46d8-b111-81eddc103a30
# ╠═374061f0-7020-4f8d-ac2c-73e60be9cb2b
# ╠═43161720-d202-4258-81d0-bfd4cbf7938f
# ╠═2786dee7-73a3-4ec2-9eba-485d704debe1
# ╠═efadc49a-d796-4dee-b0ae-be15fe83e3e0
# ╠═520a56a3-faad-4210-9002-1a72ffe0e6f3
# ╠═244bd7e2-09b8-4dc6-b916-73a4598150f1
# ╠═c4c618e3-c485-4ab0-a526-9f93437e8e65
# ╠═a51a510a-2d17-4770-b982-7ee168c6e98b
# ╠═7f4c146a-e767-4989-b74a-339aa8e7f7e2
# ╠═3b471035-860f-4a32-a149-5ce72b82ee65
# ╠═381ef733-af05-4da3-9848-b2efab9eed35
# ╠═103f93df-470b-47e2-93d9-9210ae9895e5
# ╠═8e97b385-5e8a-4cc0-9257-09b1939ba6ad
# ╠═42184826-69e6-4fa2-811d-36fe7fb219ee
# ╠═9e2a0893-8912-4549-a050-29af947c88e1
